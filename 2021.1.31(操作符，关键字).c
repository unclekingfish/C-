#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>



 ~ -对一个数的二进制按位取反
int main()
{
	int a = 2; // int 整形大小是4个字节（32个比特）
	int b = ~a;//b是有符号位的整形
	
    //如果是有符号位的数，它的最高（如果是是二进制，则是已知大小最右的一位数）位是0则是正数，1是负数
	//所以int a =2 正确的二进制位表示是
	//00000000000000000000000000000010
	//~a = 11111111111111111111111111111101

	//原码，反码，补码
	//原码符号位不变，其它位按位取反得到反码，反码加1得到补码
	//倒回去，补码先减1，得到反码，反码按位取反得到原码
	//负数在内存中存储的时候，存储是二进制的补码
	//~a的最高位是1，它是负数，则它是补码。(使用的是打印的是原码）
	//~a=11111111111111111111111111111101 减1转化为反码是11111111111111111111111111111100 ，按位取反(最高位不变）则是10000000000000000000000000000011
	//~a = -3
	printf("%d\n", b);//使用的，打印的是原码
	
	return 0;
}

总结 ：
int  整形是有符号位的。当求 int a = 0; int b = ~a;时
~符号是对一个二进制进行取反；int 整形类型 它由32位比特，
int a = 00000000000000000000000000000000;
int ~a = 11111111111111111111111111111111；
有符号位时，这个二进制数最高位（最左边的一位数）时0，则为正数；1则为负数；
原码，反码，补码
负数在内存中存储的时候，存储的时补码。
而我们使用的，打印的时候用的时原码。
所以~a最高位是1，则它是负数，存储的时候是补码。（11111111111111111111111111111111）是补码
原码，反码，补码 怎么转换呢？
原码符号位不变（最高位）不变，其它位按位取反，得到反码；反码在加1，得到补码；
而转换过来就是补码减1（11111111111111111111111111111110），得到反码；反码再按位取反（同时最高位不变），得到原码（ 10000000000000000000000000000001）
由于（10000000000000000000000000000001）最高位1, 所以~a = -1



++;--操作符

int main()
{
	int a = 10;
	//int b = a++;//后置++表示：先使用，后在++；a 11 ;b10
	//int b = ++a;//前置++表示：先++，后使用； a  11; b 11
	//int b = a--;//后置--表示：先使用，后--；a 9;b 10
	//int b = --a;//前置--表示：先--，后使用；a 9 ;b 9
	printf("%d %d\n", a, b);
	return 0;
}

单目操作符： (类型) --强制类型转换

int main()
{
	int a =(int) 3.14;  //强制 double 类型转换为 int 类型
	printf("%d\n", a);
	return 0;
}



逻辑操作符
C语言里  0为假，1为真
&&逻辑与   只有左右两边的数两个都以为真，结果才为真
||逻辑或   只要左右两边的数有一个数为真，结果为真

int main()
{
	int a = 5;
	int b = 2;
	int c = 0;
	int d = 0;
	c = a && b; //左右两边都不为0，输出结果才为 1，若左右两边有一个为0，则输出为0；
	d = a || b;//左右两边只要有一个不为0，，则输出结果都为1，若左右两边都为0，则输出结果才为0；
	printf("%d\n", c);
	printf("%d\n", d);
	return 0;
}


条件操作符：exp1 ? exp2 : exp3     exp-表达式
如果表达式(exp1)的结果为真，那表达式2（exp2）要执行，表达式2的结果为整个表达式的结果；
表达式1的结果为假，则表达式3（exp3）要执行，表达式3的结果为整个表达式的结果

int main()
{
	int a = 20;
	int b = 100;
	int max = 0;
	max = (a >b ? a:b);
	printf("%d\n", max);
	return 0;
}

逗号表达式：exp1,exp2,exp3,....expn    逗号可以隔开一串表达式


下标引用操作符

int arr[10] = { 0 }; 创建一个数组，数组有10个元素，每个元素是整形类型
arr[2];  //[]-下标引用操作符 ; [2]表示 我要访问arr这个数组下标为4的元素





函数调用操作符

int add(int x, int y)
{
	int z = 0;
     z= x + y;
	return z;
}

int main()
{
	int a = 10;
	int b = 100;
	
	int c= add(a, b);  //add(a,b) 里面的括号（）-函数调用操作符
	printf("%d\n", c);
	return 0;
}



原码，反码，补码

只要是整数，内存中存储的都是二进制的补码
正数--- 原码，反码，补码 相同
负数：

     原码                           反码                          补码
直接按照正负                   原码符号位不变                 反码+1（二进制的1）
写出的二进制序列               其他位按位取反   

-2
10000000000000000000000000000010  -原码
11111111111111111111111111111101 - 反码
11111111111111111111111111111110  -补码


常见关键字

auto: 
int main()
{
    auto int a = 10; // a- 局部变量-自动变量（自动创建，自动销毁）
    //本来局部变量前面都有一个auto,不过因为都有所以省略
    return 0;
}

register：寄存器

计算机 存储数据
            <  | >
           / 寄存器\
          /高速缓存 \
         /    内存   \
        /     硬盘    \
       <_______________>  
  一般越往上越造价越高，容量越小，访问速度越快
为什么有高速缓存和寄存器的存在？
      cpu -中央处理器   
 早期CPU在处理数据的时候一般从内存读取数据 ,CPU 多快内存多快。
 后来CPU的能力提升处理速度加快，内存的访问速度跟不上。总体变慢了
 后来就在计算机里加一些更快的存储设备；cpu处理数据可以从寄存器拿，但是寄存器没数据？就让硬盘的数据放到内存上，内存的数据放到高速缓存，高速缓存的数据放到寄存器，
 当cpu没有从寄存器拿到数据时就从下一级的高速缓存拿数据，以此类推一路拿下去
 这样cpu的速度就快了


int main()
{
    register int a = 10;//建议把a定义成寄存器变量  最终要不要还要看编译器
    return 0;
}



signed:

int main()
{
    int a = 10;
    a = -2;
    int 定义的变量是有符号的
        其实 int 叫 signed int;我们其实把signed省略
        无符号：unsigned int
    return 0;
}


struct -结构体关键字

union -联合体\共用体

关键字是不能和定义的符号名不能重复

